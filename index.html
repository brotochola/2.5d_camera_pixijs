<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS 3D con PixiJS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 14px;
        }

        #debug-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            z-index: 100;
            width: 250px;
        }

        .slider-container {
            margin: 10px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .slider-container input {
            width: 100%;
        }

        .slider-value {
            float: right;
            font-size: 12px;
        }

        #debug-panel h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #fff;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        #crosshair::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="crosshair"></div>
        <div id="ui">
            <div>WASD: Mover | Mouse: Mirar | Clic: Disparar</div>
            <div id="coords">Pos: (0, 0, 0) | Rot: 0°</div>
        </div>
        <div id="debug-panel">
            <h3>Debug Controls</h3>
            <div class="slider-container">
                <label>FOV: <span class="slider-value" id="fov-value">80</span></label>
                <input type="range" id="fov-slider" min="30" max="120" value="80">
            </div>
            <div class="slider-container">
                <label>Max Render Distance: <span class="slider-value" id="max-distance-value">110</span></label>
                <input type="range" id="max-distance-slider" min="50" max="200" value="110">
            </div>
            <div class="slider-container">
                <label>Margin Factor: <span class="slider-value" id="margin-factor-value">0.2</span></label>
                <input type="range" id="margin-factor-slider" min="-1" max="1" step="0.05" value="0.2">
            </div>
            <div class="slider-container">
                <label>Darken Factor: <span class="slider-value" id="darken-factor-value">0.7</span></label>
                <input type="range" id="darken-factor-slider" min="0" max="1" step="0.05" value="0.7">
            </div>
            <div class="slider-container">
                <label>Ground Size: <span class="slider-value" id="ground-size-value">30</span></label>
                <input type="range" id="ground-size-slider" min="10" max="50" value="30">
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script>
        // Clase para objetos 3D
        class Object3D {
            constructor(x = 0, y = 0, z = 0) {
                this.id = Math.random().toString(36).substring(2, 15);
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;
                this.scaleX = 1;
                this.scaleY = 1;
                this.scaleZ = 1;
                this.vertices = [];
                this.faces = [];
                this.color = 0xffffff;
                this.graphics = new PIXI.Graphics();
                this.shadowGraphics = new PIXI.Graphics(); // Add shadow graphics
                this.needsUpdate = true;
                this.isSprite = false;
            }

            setPosition(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.needsUpdate = true;
            }

            setRotation(x, y, z) {
                this.rotationX = x;
                this.rotationY = y;
                this.rotationZ = z;
                this.needsUpdate = true;
            }

            updateGraphics(projected) {
                if (!this.needsUpdate && !this.isSprite) return;

                this.graphics.clear();
                this.shadowGraphics.clear();

                if (this.isSprite && projected && projected.z > 0) {
                    const size = this.size * projected.scale;

                    // Draw shadow first
                    const shadowY = 0; // Shadow is always at ground level
                    const shadowProjected = this.renderer3D.project3D(this.x, shadowY, this.z, this.camera);

                    if (shadowProjected && shadowProjected.scale > 0) {
                        // Base shadow size with minimum threshold
                        const baseShadowSize = Math.max(1, size * 0.66)

                        // Simple tilt factor (0 to 1)
                        const tiltFactor = Math.abs(Math.sin(this.camera.tilt)); // 0 when horizontal, 1 when vertical

                        // Calculate opacity
                        const heightFactor = Math.min(Math.max(0, this.y / 10), 1);
                        const distanceFactor = Math.min(Math.max(0, shadowProjected.z / 50), 1);
                        const shadowAlpha = Math.min(Math.max(0.1, 0.4 - heightFactor * 0.2 - distanceFactor * 0.2), 0.4);

                        // Gentle shadow stretching
                        const radiusX = Math.max(1, baseShadowSize * (1.5 - tiltFactor * 0.5)) + heightFactor;
                        const radiusY = Math.max(1, baseShadowSize * tiltFactor) + heightFactor;

                        // Simple offset based on height and tilt
                        const offsetX = -this.y * 0.5 * tiltFactor;
                        const offsetY = radiusY * 0.5;

                        try {
                            this.shadowGraphics.clear();
                            this.shadowGraphics.beginFill(0x000000, shadowAlpha * 0.5);
                            this.shadowGraphics.drawEllipse(
                                shadowProjected.x + offsetX,
                                shadowProjected.y + offsetY,
                                radiusX,
                                radiusY
                            );
                            this.shadowGraphics.endFill();
                        } catch (error) {
                            console.warn('Shadow drawing error:',
                                { radiusX, radiusY, x: shadowProjected.x + offsetX, y: shadowProjected.y + offsetY },
                                error
                            );
                        }

                        // Draw sprite
                        this.graphics.beginFill(this.color);
                        this.graphics.drawCircle(projected.x, projected.y, size);
                        this.graphics.endFill();
                    }
                }

                this.needsUpdate = false;
            }
        }

        // Clase Cámara
        class Camera {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotationY = 3; // Rotación horizontal
                this.tilt = 0;      // Rotación vertical
                this.fov = 80;      // Campo de visión
                this.near = 0.1;
                this.far = 90;
            }
            transitionToNewPosition(x, y, z, tilt, rotationY, fov) {
                this.targetX = x;
                this.targetY = y;
                this.targetZ = z;
                this.targetTilt = tilt;
                this.targetRotationY = rotationY;
                this.targetFov = fov;
                this.transitioning = true;
            }

            move(dx, dy, dz) {
                // Movimiento relativo a la rotación de la cámara
                const cos = Math.cos(this.rotationY);
                const sin = Math.sin(this.rotationY);

                this.x += dx * cos - dz * sin;
                this.z += dx * sin + dz * cos;
                this.y += dy;
                this.stopTransitioning()
            }
            stopTransitioning() {
                this.transitioning = false
                this.targetX = null
                this.targetY = null
                this.targetZ = null
                this.targetTilt = null
                this.targetRotationY = null
                this.targetFov = null
            }

            rotate(deltaY, deltaTilt) {
                this.stopTransitioning()

                this.rotationY += deltaY;
                this.tilt += deltaTilt;

                // Limitar el tilt para evitar que se voltee completamente
                this.tilt = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.tilt));
            }

            getViewMatrix() {
                return {
                    x: this.x,
                    y: this.y,
                    z: this.z,
                    rotationY: this.rotationY,
                    tilt: this.tilt
                };
            }
            update() {
                if (this.targetX !== null && this.targetX !== undefined && this.transitioning) {
                    const lerpFactor = 0.05;
                    this.x += (this.targetX - this.x) * lerpFactor;
                    this.y += (this.targetY - this.y) * lerpFactor;
                    this.z += (this.targetZ - this.z) * lerpFactor;
                    this.tilt += (this.targetTilt - this.tilt) * lerpFactor;
                    this.rotationY += (this.targetRotationY - this.rotationY) * lerpFactor;
                    this.fov += (this.targetFov - this.fov) * lerpFactor;
                    if (Math.sqrt(Math.pow(this.x - this.targetX, 2) + Math.pow(this.y - this.targetY, 2) + Math.pow(this.z - this.targetZ, 2)) < 5) {
                        if (Math.abs(this.tilt - this.targetTilt) < 0.01 && Math.abs(this.rotationY - this.targetRotationY) < 0.01 && Math.abs(this.fov - this.targetFov) < 0.01) {
                            this.transitioning = false;
                        }
                    }
                }
            }
            isometricView() {
                this.transitionToNewPosition(34, 63, 41, 0.76, 2.36, 40);
            }
            normalView() {
                this.transitionToNewPosition(10, 6, 33, 0, 3, 50);
            }
        }

        // Renderer 3D
        class Renderer3D {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.centerX = width / 2;
                this.centerY = height / 2;
                this.zBuffer = new Array(width * height);
                this.maxDistanceToRender = 110
                this.marginFactor = 0.2
            }

            calculateFocalLength(fov) {
                // Convert FOV from degrees to radians and calculate focal length
                const fovRadians = (fov * Math.PI) / 180;
                return (this.width / 2) / Math.tan(fovRadians / 2);
            }

            calculateScreenMargin() {
                // Calculate margin based on screen dimensions and focal length
                // We want the margin to be proportional to the screen size
                // but also consider the focal length to account for FOV
                const baseMargin = Math.min(this.width, this.height) * this.marginFactor; // 20% of smaller screen dimension
                return baseMargin;
            }

            project3D(x, y, z, camera) {
                this.focalLength = this.calculateFocalLength(camera.fov);
                // Transformar coordenadas relativas a la cámara
                const dx = x - camera.x;
                const dy = y - camera.y;
                const dz = z - camera.z;

                // Aplicar rotación de la cámara
                const cosY = Math.cos(-camera.rotationY);
                const sinY = Math.sin(-camera.rotationY);
                const cosTilt = Math.cos(-camera.tilt);
                const sinTilt = Math.sin(-camera.tilt);

                // Rotación Y (horizontal)
                const x1 = dx * cosY - dz * sinY;
                const z1 = dx * sinY + dz * cosY;
                const y1 = dy;

                // Rotación X (tilt)
                const y2 = y1 * cosTilt - z1 * sinTilt;
                const z2 = y1 * sinTilt + z1 * cosTilt;
                const x2 = x1;

                // Proyección perspectiva
                if (z2 < 0.01) return null; // Minimum distance from camera

                // Calculate focal length based on camera's FOV
                const scale = this.focalLength / z2;
                const screenX = this.centerX + x2 * scale;
                const screenY = this.centerY - y2 * scale;

                const margin = this.calculateScreenMargin();

                // Check if point is within screen bounds with dynamic margin
                const isVisible = screenX >= -margin && screenX <= this.width + margin &&
                    screenY >= -margin && screenY <= this.height + margin;

                return {
                    x: screenX,
                    y: screenY,
                    z: z2,
                    scale: scale,
                    isVisible: isVisible
                };
            }

            clearZBuffer() {
                this.zBuffer.fill(Infinity);
            }
        }

        // Crear sprite 3D con billboarding
        function createSprite3D(x, y, z, size = 1, color = 0xff0000) {
            const sprite = new Object3D(x, y, z);
            sprite.size = size;
            sprite.color = color;
            sprite.isSprite = true;
            sprite.needsUpdate = true;
            return sprite;
        }

        // Crear piso
        function createGround(size = 20) {
            const ground = new Object3D(0, 0, 0);
            ground.color = 0x99ff99;
            ground.vertices = [];
            ground.faces = [];

            // Crear grid del piso con más densidad cerca de la cámara
            const step = 2;
            for (let x = -size * 2; x <= size * 2; x += step) {  // Extended size
                for (let z = -size * 2; z <= size * 2; z += step) {  // Extended size
                    const baseIndex = ground.vertices.length;
                    const y = 0
                    ground.vertices.push(
                        [x, y, z],
                        [x + step, y, z],
                        [x + step, y, z + step],
                        [x, y, z + step]
                    );
                    ground.faces.push([baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 3]);
                }
            }

            return ground;
        }

        // Inicializar el juego
        class Game {
            constructor() {
                this.app = new PIXI.Application({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: 0x87CEEB,
                    antialias: true
                });

                document.getElementById('gameContainer').appendChild(this.app.view);

                this.renderer3D = new Renderer3D(window.innerWidth, window.innerHeight);
                this.camera = new Camera(1, 2, 10);
                this.objects = [];
                this.groundSize = 30;
                this.darkenFactor = 0.7;

                this.setupDebugControls();
                this.createWorld();
                this.setupControls();
                this.setupGameLoop();
            }

            setupDebugControls() {
                // FOV Slider
                const fovSlider = document.getElementById('fov-slider');
                const fovValue = document.getElementById('fov-value');
                fovSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.camera.fov = value;
                    fovValue.textContent = value;
                });

                // Max Distance Slider
                const maxDistanceSlider = document.getElementById('max-distance-slider');
                const maxDistanceValue = document.getElementById('max-distance-value');
                maxDistanceSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.renderer3D.maxDistanceToRender = value;
                    maxDistanceValue.textContent = value;
                });

                // Margin Factor Slider
                const marginFactorSlider = document.getElementById('margin-factor-slider');
                const marginFactorValue = document.getElementById('margin-factor-value');
                marginFactorSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.renderer3D.marginFactor = value;
                    marginFactorValue.textContent = value.toFixed(2);
                });

                // Darken Factor Slider
                const darkenFactorSlider = document.getElementById('darken-factor-slider');
                const darkenFactorValue = document.getElementById('darken-factor-value');
                darkenFactorSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.darkenFactor = value;
                    darkenFactorValue.textContent = value.toFixed(2);
                });

                // Ground Size Slider
                const groundSizeSlider = document.getElementById('ground-size-slider');
                const groundSizeValue = document.getElementById('ground-size-value');
                groundSizeSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    this.groundSize = value;
                    this.recreateGround();
                    groundSizeValue.textContent = value;
                });
            }

            createWorld() {
                // Create ground and other objects
                this.ground = createGround(this.groundSize);
                this.objects.push(this.ground);
                this.app.stage.addChild(this.ground.graphics);  // Add ground graphics first

                // Create sprites with their shadows
                const sprites = [
                    createSprite3D(0, 3, 0.5, 1, 0xff0000),
                    createSprite3D(5, 4, 0.5, 1, 0x00ff00),
                    createSprite3D(-3, 3, 1.5, 1, 0x0000ff),
                    createSprite3D(2, 3, 0.5, 1, 0xffff00),
                    createSprite3D(-8, 5, 1.2, 1, 0xff00ff),
                    createSprite3D(7, 2.5, 0.6, 1, 0x00ffff)
                ];

                // Add sprites and their shadows
                for (const sprite of sprites) {
                    this.objects.push(sprite);
                    this.app.stage.addChild(sprite.shadowGraphics); // Add shadow first (render below sprite)
                    this.app.stage.addChild(sprite.graphics);
                }
            }

            recreateGround() {
                // Remove old ground
                const groundIndex = this.objects.indexOf(this.ground);
                if (groundIndex !== -1) {
                    this.app.stage.removeChild(this.ground.graphics);
                    this.objects.splice(groundIndex, 1);
                }

                // Create new ground
                this.ground = createGround(this.groundSize);
                this.objects.unshift(this.ground);
                this.app.stage.addChild(this.ground.graphics);  // Don't forget to add graphics when recreating
            }

            setupControls() {
                this.keys = {};
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseSensitivity = 0.001;

                // Eventos de teclado
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (this.keys['KeyI'] && !this.camera.transitioning) this.camera.isometricView();
                    if (this.keys['KeyO'] && !this.camera.transitioning) this.camera.normalView();
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Eventos de ratón - Corregido
                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement === this.app.view) {
                        console.log('Mouse bloqueado');
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === this.app.view) {
                        this.camera.rotate(
                            -e.movementX * this.mouseSensitivity,
                            e.movementY * this.mouseSensitivity
                        );
                    }
                });

                // Clic para bloquear mouse
                this.app.view.addEventListener('click', () => {
                    if (document.pointerLockElement !== this.app.view) {
                        this.app.view.requestPointerLock();
                    } else {
                        this.shoot();
                    }
                });

                // Prevenir menú contextual
                this.app.view.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            shoot() {
                // Crear efecto de disparo
                const muzzleFlash = new PIXI.Graphics();
                muzzleFlash.beginFill(0xffff00);
                muzzleFlash.drawCircle(this.app.screen.width / 2, this.app.screen.height / 2, 10);
                muzzleFlash.endFill();
                this.app.stage.addChild(muzzleFlash);

                setTimeout(() => {
                    this.app.stage.removeChild(muzzleFlash);
                }, 100);
            }
            whoIsTHeCameraAimingTo() {
                const centerX = this.app.screen.width / 2;
                const centerY = this.app.screen.height / 2;
                let closestObject = null;
                let closestDistance = Infinity;

                for (const obj of this.objects) {
                    if (!obj.isSprite) continue; // Skip non-sprite objects

                    const bounds = obj.graphics.getBounds();

                    // Check if center of screen is within the sprite bounds
                    if (centerX >= bounds.left && centerX <= bounds.right &&
                        centerY >= bounds.top && centerY <= bounds.bottom) {
                        return obj
                    }
                }

                return null
            }

            handleInput() {
                const speed = 0.1;

                if (this.keys['KeyW']) this.camera.move(0, 0, speed);  // Corregido: W avanza
                if (this.keys['KeyS']) this.camera.move(0, 0, -speed); // Corregido: S retrocede
                if (this.keys['KeyA']) this.camera.move(-speed, 0, 0);
                if (this.keys['KeyD']) this.camera.move(speed, 0, 0);
                if (this.keys['Space']) this.camera.move(0, speed, 0);
                if (this.keys['ShiftLeft']) this.camera.move(0, -speed, 0);
            }
            update() {
                for (const obj of this.objects.filter(k => k.isSprite)) {
                    // Update positions with movement
                    const randomSign = Math.random() > 0.5 ? -1 : 1
                    // obj.x += Math.sin((performance.now()) / 1000 - obj.size) * 0.08 + (Math.random() - 0.5) * 0.1
                    obj.y += Math.cos(performance.now() / 1000) * 0.04
                    // obj.z += randomSign * Math.cos(performance.now() / 1000) * 0.04 + (Math.random() - 0.5) * 0.1

                    //-------------
                    // Ground collision check
                    const groundLevel = 0;
                    const objectRadius = obj.size;

                    if (obj.y - objectRadius < groundLevel) {
                        // Place object exactly at ground level plus radius
                        obj.y = groundLevel + objectRadius;


                    }
                }
            }

            render() {
                this.renderer3D.clearZBuffer();

                // Separate ground from other objects
                const ground = this.objects.find(obj => !obj.isSprite);
                const sprites = this.objects.filter(obj => obj.isSprite);

                // Render ground first
                if (ground) {
                    this.renderObject(ground);
                }

                // Calculate distances and sort sprites from farthest to nearest
                const spritesWithDistance = sprites.map(obj => {
                    const dx = obj.x - this.camera.x;
                    const dy = obj.y - this.camera.y;
                    const dz = obj.z - this.camera.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    return { obj, distance };
                });

                // Sort sprites by distance (farthest first)
                spritesWithDistance.sort((a, b) => b.distance - a.distance);

                // Update sprite positions in stage based on z-order
                for (const { obj } of spritesWithDistance) {
                    this.app.stage.removeChild(obj.graphics);
                    this.app.stage.addChild(obj.graphics);
                    this.renderObject(obj);
                }
                this.camera.update();
                // Actualizar UI
                this.updateUI();
            }

            renderObject(obj) {
                if (obj.isSprite) {
                    this.renderSprite(obj);
                } else {
                    this.renderMesh(obj);
                }
            }

            renderSprite(sprite) {
                const projected = this.renderer3D.project3D(sprite.x, sprite.y, sprite.z, this.camera);
                sprite.renderer3D = this.renderer3D;
                sprite.camera = this.camera;
                sprite.updateGraphics(projected);
            }

            renderMesh(obj) {
                const projectedVertices = [];

                for (const vertex of obj.vertices) {
                    const worldX = vertex[0] + obj.x;
                    const worldY = vertex[1] + obj.y;
                    const worldZ = vertex[2] + obj.z;

                    const projected = this.renderer3D.project3D(worldX, worldY, worldZ, this.camera);
                    projectedVertices.push(projected);
                }

                obj.graphics.clear();
                this.numberOfVisibleFaces = 0;

                for (const face of obj.faces) {
                    const faceVertices = face.map(i => projectedVertices[i]).filter(v => v !== null);

                    if (faceVertices.length >= 3 && faceVertices.some(v => v.isVisible)) {
                        this.numberOfVisibleFaces++;
                        const avgZ = faceVertices.reduce((sum, v) => sum + v.z, 0) / faceVertices.length;

                        const maxDistance = this.renderer3D.maxDistanceToRender * 0.9;
                        const minDistance = 5;
                        const distanceFactor = Math.min(Math.max((avgZ - minDistance) / (maxDistance - minDistance), 0), 1);

                        if (avgZ > this.renderer3D.maxDistanceToRender) {
                            continue;
                        }

                        const r = (obj.color >> 16) & 0xFF;
                        const g = (obj.color >> 8) & 0xFF;
                        const b = obj.color & 0xFF;

                        // Use the darkenFactor from the slider
                        const darkFactor = 1 - (distanceFactor * this.darkenFactor);
                        const newR = Math.floor(r * darkFactor);
                        const newG = Math.floor(g * darkFactor);
                        const newB = Math.floor(b * darkFactor);

                        const shadedColor = (newR << 16) | (newG << 8) | newB;

                        obj.graphics.beginFill(shadedColor);
                        obj.graphics.moveTo(faceVertices[0].x, faceVertices[0].y);

                        for (let i = 1; i < faceVertices.length; i++) {
                            obj.graphics.lineTo(faceVertices[i].x, faceVertices[i].y);
                        }

                        obj.graphics.closePath();
                        obj.graphics.endFill();

                        obj.graphics.lineStyle(1, 0x000000, 0.1);
                        obj.graphics.moveTo(faceVertices[0].x, faceVertices[0].y);
                        for (let i = 1; i < faceVertices.length; i++) {
                            obj.graphics.lineTo(faceVertices[i].x, faceVertices[i].y);
                        }
                        obj.graphics.closePath();
                        obj.graphics.lineStyle(0);
                    }
                }
                obj.ratioOfVisibleFaces = this.numberOfVisibleFaces / obj.faces.length;
            }

            updateUI() {
                const coords = document.getElementById('coords');
                coords.textContent = `Pos: (${this.camera.x.toFixed(1)}, ${this.camera.y.toFixed(1)}, ${this.camera.z.toFixed(1)}) | Rot: ${(this.camera.rotationY * 180 / Math.PI).toFixed(0)}°`;
            }

            setupGameLoop() {
                this.app.ticker.add(() => {
                    this.handleInput();
                    this.update()
                    this.render();
                });
            }
        }

        // Iniciar el juego
        const game = new Game();

        // Redimensionar ventana
        window.addEventListener('resize', () => {
            game.app.renderer.resize(window.innerWidth, window.innerHeight);
            game.renderer3D.width = window.innerWidth;
            game.renderer3D.height = window.innerHeight;
            game.renderer3D.centerX = window.innerWidth / 2;
            game.renderer3D.centerY = window.innerHeight / 2;
        });
    </script>
</body>
</html>