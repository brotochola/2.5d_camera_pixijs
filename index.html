<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPS 3D con PixiJS</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 14px;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 100;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }

        #crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        #crosshair::after {
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="crosshair"></div>
        <div id="ui">
            <div>WASD: Mover | Mouse: Mirar | Clic: Disparar</div>
            <div id="coords">Pos: (0, 0, 0) | Rot: 0°</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
    <script>
        // Clase para objetos 3D
        class Object3D {
            constructor(x = 0, y = 0, z = 0) {
                this.id = Math.random().toString(36).substring(2, 15);
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotationX = 0;
                this.rotationY = 0;
                this.rotationZ = 0;
                this.scaleX = 1;
                this.scaleY = 1;
                this.scaleZ = 1;
                this.vertices = [];
                this.faces = [];
                this.color = 0xffffff;
                this.graphics = new PIXI.Graphics();
                this.needsUpdate = true;
                this.isSprite = false;
            }

            setPosition(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.needsUpdate = true;
            }

            setRotation(x, y, z) {
                this.rotationX = x;
                this.rotationY = y;
                this.rotationZ = z;
                this.needsUpdate = true;
            }

            updateGraphics(projected) {
                if (!this.needsUpdate && !this.isSprite) return;

                this.graphics.clear();

                if (this.isSprite && projected && projected.z > 0) {
                    const size = this.size * projected.scale;

                    // Dibujar sprite como círculo
                    this.graphics.beginFill(this.color);
                    this.graphics.drawCircle(projected.x, projected.y, size);
                    this.graphics.endFill();

                    // Contorno
                    this.graphics.lineStyle(2, 0x000000, 0.8);
                    this.graphics.drawCircle(projected.x, projected.y, size);
                    this.graphics.lineStyle(0);

                    // Highlight interno
                    this.graphics.beginFill(0xffffff, 0.3);
                    this.graphics.drawCircle(projected.x - size * 0.3, projected.y - size * 0.3, size * 0.3);
                    this.graphics.endFill();
                }

                this.needsUpdate = false;
            }
        }

        // Clase Cámara
        class Camera {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.rotationY = 3; // Rotación horizontal
                this.tilt = 0;      // Rotación vertical
                this.fov = 80;      // Campo de visión
                this.near = 0.1;
                this.far = 1000;
            }
            transitionToNewPosition(x, y, z, tilt, rotationY, fov) {
                this.targetX = x;
                this.targetY = y;
                this.targetZ = z;
                this.targetTilt = tilt;
                this.targetRotationY = rotationY;
                this.targetFov = fov;
                this.transitioning = true;



            }

            move(dx, dy, dz) {

                // Movimiento relativo a la rotación de la cámara
                const cos = Math.cos(this.rotationY);
                const sin = Math.sin(this.rotationY);

                this.x += dx * cos - dz * sin;
                this.z += dx * sin + dz * cos;
                this.y += dy;
                this.stopTransitioning()
            }
            stopTransitioning() {
                this.transitioning = false
                this.targetX = null
                this.targetY = null
                this.targetZ = null
                this.targetTilt = null
                this.targetRotationY = null
                this.targetFov = null
            }

            rotate(deltaY, deltaTilt) {
                this.stopTransitioning()

                this.rotationY += deltaY;
                this.tilt += deltaTilt;

                // Limitar el tilt para evitar que se voltee completamente
                this.tilt = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.tilt));
            }

            getViewMatrix() {
                return {
                    x: this.x,
                    y: this.y,
                    z: this.z,
                    rotationY: this.rotationY,
                    tilt: this.tilt
                };
            }
            update() {
                if (this.targetX !== null && this.targetX !== undefined && this.transitioning) {
                    const lerpFactor = 0.05;
                    this.x += (this.targetX - this.x) * lerpFactor;
                    this.y += (this.targetY - this.y) * lerpFactor;
                    this.z += (this.targetZ - this.z) * lerpFactor;
                    this.tilt += (this.targetTilt - this.tilt) * lerpFactor;
                    this.rotationY += (this.targetRotationY - this.rotationY) * lerpFactor;
                    this.fov += (this.targetFov - this.fov) * lerpFactor;
                    if (Math.sqrt(Math.pow(this.x - this.targetX, 2) + Math.pow(this.y - this.targetY, 2) + Math.pow(this.z - this.targetZ, 2)) < 5) {
                        if (Math.abs(this.tilt - this.targetTilt) < 0.01 && Math.abs(this.rotationY - this.targetRotationY) < 0.01 && Math.abs(this.fov - this.targetFov) < 0.01) {
                            this.transitioning = false;
                        }

                    }
                }
            }
            isometricView() {
                this.transitionToNewPosition(34, 63, 41, 0.76, 2.36, 40);
            }
            normalView() {
                this.transitionToNewPosition(10, 6, 33, 0, 3, 50);
            }
        }

        // Renderer 3D
        class Renderer3D {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.centerX = width / 2;
                this.centerY = height / 2;
                this.zBuffer = new Array(width * height);

            }

            calculateFocalLength(fov) {
                // Convert FOV from degrees to radians and calculate focal length
                const fovRadians = (fov * Math.PI) / 180;
                return (this.width / 2) / Math.tan(fovRadians / 2);
            }

            project3D(x, y, z, camera) {
                this.focalLength = this.calculateFocalLength(camera.fov);
                // Transformar coordenadas relativas a la cámara
                const dx = x - camera.x;
                const dy = y - camera.y;
                const dz = z - camera.z;

                // Aplicar rotación de la cámara
                const cosY = Math.cos(-camera.rotationY);
                const sinY = Math.sin(-camera.rotationY);
                const cosTilt = Math.cos(-camera.tilt);
                const sinTilt = Math.sin(-camera.tilt);

                // Rotación Y (horizontal)
                const x1 = dx * cosY - dz * sinY;
                const z1 = dx * sinY + dz * cosY;
                const y1 = dy;

                // Rotación X (tilt)
                const y2 = y1 * cosTilt - z1 * sinTilt;
                const z2 = y1 * sinTilt + z1 * cosTilt;
                const x2 = x1;

                // Proyección perspectiva
                if (z2 < 0.01) return null; // Minimum distance from camera

                // Calculate focal length based on camera's FOV

                const scale = this.focalLength / z2;
                const screenX = this.centerX + x2 * scale;
                const screenY = this.centerY - y2 * scale;

                return {
                    x: screenX,
                    y: screenY,
                    z: z2,
                    scale: scale
                };
            }

            clearZBuffer() {
                this.zBuffer.fill(Infinity);
            }
        }

        // Crear sprite 3D con billboarding
        function createSprite3D(x, y, z, size = 1, color = 0xff0000) {
            const sprite = new Object3D(x, y, z);
            sprite.size = size;
            sprite.color = color;
            sprite.isSprite = true;
            sprite.needsUpdate = true;
            return sprite;
        }

        // Crear piso
        function createGround(size = 20) {
            const ground = new Object3D(0, 0, 0);
            ground.color = 0x444444;
            ground.vertices = [];
            ground.faces = [];

            // Crear grid del piso con más densidad cerca de la cámara
            const step = 2;
            for (let x = -size * 2; x <= size * 2; x += step) {  // Extended size
                for (let z = -size * 2; z <= size * 2; z += step) {  // Extended size
                    const baseIndex = ground.vertices.length;
                    ground.vertices.push(
                        [x, 0, z],
                        [x + step, 0, z],
                        [x + step, 0, z + step],
                        [x, 0, z + step]
                    );
                    ground.faces.push([baseIndex, baseIndex + 1, baseIndex + 2, baseIndex + 3]);
                }
            }

            return ground;
        }

        // Inicializar el juego
        class Game {
            constructor() {
                this.app = new PIXI.Application({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    backgroundColor: 0x87CEEB,
                    antialias: true
                });

                document.getElementById('gameContainer').appendChild(this.app.view);

                this.renderer3D = new Renderer3D(window.innerWidth, window.innerHeight);
                this.camera = new Camera(1, 2, 10);
                this.objects = [];

                // Crear objetos del mundo
                this.objects.push(createGround(20));
                this.objects.push(createSprite3D(0, 3, 0.5, 1, 0xff0000));
                this.objects.push(createSprite3D(5, 4, 0.5, 1, 0x00ff00));
                this.objects.push(createSprite3D(-3, 3, 1.5, 1, 0x0000ff));
                this.objects.push(createSprite3D(2, 3, 0.5, 1, 0xffff00));
                this.objects.push(createSprite3D(-8, 5, 1.2, 1, 0xff00ff));
                this.objects.push(createSprite3D(7, 2.5, 0.6, 1, 0x00ffff));

                // Add all object graphics to stage
                for (const obj of this.objects) {
                    this.app.stage.addChild(obj.graphics);
                }

                this.setupControls();
                this.setupGameLoop();
            }

            setupControls() {
                this.keys = {};
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseSensitivity = 0.001;

                // Eventos de teclado
                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;

                    if (this.keys['KeyI'] && !this.camera.transitioning) this.camera.isometricView();
                    if (this.keys['KeyO'] && !this.camera.transitioning) this.camera.normalView();
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Eventos de ratón - Corregido
                document.addEventListener('pointerlockchange', () => {
                    if (document.pointerLockElement === this.app.view) {
                        console.log('Mouse bloqueado');
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (document.pointerLockElement === this.app.view) {
                        this.camera.rotate(
                            -e.movementX * this.mouseSensitivity,
                            e.movementY * this.mouseSensitivity
                        );
                    }
                });

                // Clic para bloquear mouse
                this.app.view.addEventListener('click', () => {
                    if (document.pointerLockElement !== this.app.view) {
                        this.app.view.requestPointerLock();
                    } else {
                        this.shoot();
                    }
                });

                // Prevenir menú contextual
                this.app.view.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }

            shoot() {
                // Crear efecto de disparo
                const muzzleFlash = new PIXI.Graphics();
                muzzleFlash.beginFill(0xffff00);
                muzzleFlash.drawCircle(this.app.screen.width / 2, this.app.screen.height / 2, 10);
                muzzleFlash.endFill();
                this.app.stage.addChild(muzzleFlash);

                setTimeout(() => {
                    this.app.stage.removeChild(muzzleFlash);
                }, 100);
            }
            whoIsTHeCameraAimingTo() {
                const centerX = this.app.screen.width / 2;
                const centerY = this.app.screen.height / 2;
                let closestObject = null;
                let closestDistance = Infinity;

                for (const obj of this.objects) {
                    if (!obj.isSprite) continue; // Skip non-sprite objects

                    const bounds = obj.graphics.getBounds();

                    // Check if center of screen is within the sprite bounds
                    if (centerX >= bounds.left && centerX <= bounds.right &&
                        centerY >= bounds.top && centerY <= bounds.bottom) {
                        return obj

                    }
                }

                return null


            }

            handleInput() {
                const speed = 0.1;

                if (this.keys['KeyW']) this.camera.move(0, 0, speed);  // Corregido: W avanza
                if (this.keys['KeyS']) this.camera.move(0, 0, -speed); // Corregido: S retrocede
                if (this.keys['KeyA']) this.camera.move(-speed, 0, 0);
                if (this.keys['KeyD']) this.camera.move(speed, 0, 0);
                if (this.keys['Space']) this.camera.move(0, speed, 0);
                if (this.keys['ShiftLeft']) this.camera.move(0, -speed, 0);

            }

            render() {
                this.renderer3D.clearZBuffer();

                // Separate ground from other objects
                const ground = this.objects.find(obj => !obj.isSprite);
                const sprites = this.objects.filter(obj => obj.isSprite);

                // Render ground first
                if (ground) {
                    this.renderObject(ground);
                }

                // Calculate distances and sort sprites from farthest to nearest
                const spritesWithDistance = sprites.map(obj => {
                    const dx = obj.x - this.camera.x;
                    const dy = obj.y - this.camera.y;
                    const dz = obj.z - this.camera.z;
                    const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    return { obj, distance };
                });

                // Sort sprites by distance (farthest first)
                spritesWithDistance.sort((a, b) => b.distance - a.distance);

                // Update sprite positions in stage based on z-order
                for (const { obj } of spritesWithDistance) {
                    this.app.stage.removeChild(obj.graphics);
                    this.app.stage.addChild(obj.graphics);
                    this.renderObject(obj);
                }
                this.camera.update();
                // Actualizar UI
                this.updateUI();
            }

            renderObject(obj) {
                if (obj.isSprite) {
                    this.renderSprite(obj);
                } else {
                    this.renderMesh(obj);
                }
            }

            renderSprite(sprite) {
                const projected = this.renderer3D.project3D(sprite.x, sprite.y, sprite.z, this.camera);
                sprite.updateGraphics(projected);
            }

            renderMesh(obj) {
                const projectedVertices = [];

                // Project all vertices
                for (const vertex of obj.vertices) {
                    const worldX = vertex[0] + obj.x;
                    const worldY = vertex[1] + obj.y;
                    const worldZ = vertex[2] + obj.z;

                    const projected = this.renderer3D.project3D(worldX, worldY, worldZ, this.camera);
                    projectedVertices.push(projected);
                }

                // Update mesh graphics
                obj.graphics.clear();

                // Render faces
                for (const face of obj.faces) {
                    const faceVertices = face.map(i => projectedVertices[i]).filter(v => v !== null);

                    if (faceVertices.length >= 3) {
                        obj.graphics.beginFill(obj.color);
                        obj.graphics.moveTo(faceVertices[0].x, faceVertices[0].y);

                        for (let i = 1; i < faceVertices.length; i++) {
                            obj.graphics.lineTo(faceVertices[i].x, faceVertices[i].y);
                        }

                        obj.graphics.closePath();
                        obj.graphics.endFill();

                        // Contorno
                        obj.graphics.lineStyle(1, 0x000000, 0.3);
                        obj.graphics.moveTo(faceVertices[0].x, faceVertices[0].y);
                        for (let i = 1; i < faceVertices.length; i++) {
                            obj.graphics.lineTo(faceVertices[i].x, faceVertices[i].y);
                        }
                        obj.graphics.closePath();
                        obj.graphics.lineStyle(0);
                    }
                }
            }

            updateUI() {
                const coords = document.getElementById('coords');
                coords.textContent = `Pos: (${this.camera.x.toFixed(1)}, ${this.camera.y.toFixed(1)}, ${this.camera.z.toFixed(1)}) | Rot: ${(this.camera.rotationY * 180 / Math.PI).toFixed(0)}°`;
            }

            setupGameLoop() {
                this.app.ticker.add(() => {
                    this.handleInput();
                    this.render();
                });
            }
        }

        // Iniciar el juego
        const game = new Game();

        // Redimensionar ventana
        window.addEventListener('resize', () => {
            game.app.renderer.resize(window.innerWidth, window.innerHeight);
            game.renderer3D.width = window.innerWidth;
            game.renderer3D.height = window.innerHeight;
            game.renderer3D.centerX = window.innerWidth / 2;
            game.renderer3D.centerY = window.innerHeight / 2;
        });
    </script>
</body>
</html>